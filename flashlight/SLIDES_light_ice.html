<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Statistics with R</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Statistics with R
## Statistical Modelling with R for Actuarial Students

---




&lt;style type="text/css"&gt;
pre {
  background: #ADD8E6;
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;

---



light_ice Individual Conditional Expectation (ICE)

#### Description

Generates Individual Conditional Expectation (ICE) profiles. An ICE profile shows how the prediction
of an observation changes if one or multiple variables are systematically changed across its
ranges, holding all other values fixed [1]. The curves can be centered in order to increase visibility
of interaction effects. Centering is done within subgroups specified by "by".

---

#### Usage
&lt;pre&gt;&lt;code&gt;

light_ice(x, ...)
## Default S3 method:
light_ice(x, ...)
## S3 method for class 'flashlight'
light_ice(xNULL, data = x$data, by = x$by,
evaluate_at = NULL, breaks = NULL, grid = NULL, n_bins = 27,
cut_type = c("equal", "quantile"), indices = NULL, n_max = 20,
seed = NULL, use_linkinv = TRUE, center = FALSE,
value_name = "value", label_name = "label", id_name = "id", ...)
## S3 method for class 'multiflashlight'
light_ice(x, ...)

&lt;/code&gt;&lt;/pre&gt;

---

Arguments
* ``x``: An object of class flashlight or multiflashlight.
... Further arguments passed to or from other methods.
v The variable to be profiled.
* ``data``: An optionaldata.frame.
* ``by``: An optional vector of column names used to additionally group the results.
evaluate_at Vector with values of v used to evaluate the profile.
breaks Instead of evaluate_at (and grid), cut points for x can be provided. From them, ``evaluate_at`` values are calculates as averages.

---

grid A data.frame with grid values as those generated by ``expand.grid``.
n_bins Maximum number of unique values to evaluate for numeric v. Only used in
neither grid nor evaluate_at is specified.
``cut_type`` For the default "equal", bins of equal width are created for v by pretty. Choose
"quantile" to create quantile bins. Only used in neither grid nor ``evaluate_at`` is specified.
indices A vector of row numbers to consider.

---

* ***n_max*** If indices is not given, maximum number of rows to consider. Will be randomly picked from data if necessary.
seed An integer random seed.
use_linkinv Should retransformation function be applied? Default is TRUE.
center Should curves be centered? Default is FALSE. Note that centering will be done
at the first evaluation point and within "by" group. It will work also for a grid
with multiple columns.
value_name Column name in resulting data containing the profile value. Defaults to "value".
* ``label_name``: Column name in resulting data containing the label of the flashlight. Defaults
to "label".
id_name Column name in resulting data containing the row id of the profile. Defaults to
"id_name".

---

#### Details

There are two ways to specify the variable(s) to be profiled. The first option is to pass the variable
name via v and an optional vector with evaluation points evaluate_at (or breaks). This works for dependence on a single variable. The second option is much more general: You can specify any
grid as a data.frame with one or more columns. It can e.g. be generated by a call to expand.grid.
Currently, there is no option to pass more than one variable name without such grid. The minimum
required elements in the (multi-)flashlight are "``predict_function``", "model", "linkinv" and "data",
where the latest can be passed on the fly. Which rows in data are profiled? This is specified by indices. If not given and n_max is smaller than the number of rows in data, then row indices
will be sampled randomly from data. If the same rows should be used for all flashlights in a multiflashlight, there are two options: Either pass a seed (with potentially undesired consequences
for subsequent code) or a vector of indices used to select rows. In both cases, data should be the
same for all flashlights considered.

#### Value

An object of class light_ice, light (and a list) with the following elements.
*  data A tibble containing the results. Can be used to build fully customized visualizations. Its
column names are specified by all other items in this list.
*  by Same as input by.
*  v The variable(s) evaluated. @item center Flag if ICE curves are centered.
*  value_name Same as input value_name.
*  label_name Same as input label_name.
*  id_name Same as input id_name.
Methods (by class)
*  default: Default method not implemented yet.
*  flashlight: ICE profiles for a flashlight object.
*  multiflashlight: ICE profiles for a multiflashlight object.

---

#### Examples

```r
fit_full &lt;- lm(Sepal.Length ~ ., data = iris)
fit_part &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
mod_full &lt;- flashlight(model = fit_full, label = "full", data = iris, y = "Sepal.Length")
```

---


```r
mod_part &lt;- flashlight(model = fit_part, label = "part", data = iris, y = "Sepal.Length")
mods &lt;- multiflashlight(list(mod_full, mod_part))
```

---


```r
grid &lt;- expand.grid(Species = levels(iris$Species), Petal.Length = 2:4)
light_ice(mod_full, v = "Species")
```

```
## 
## I am an object of class light_ice 
## 
## data.frames:
## 
##  data 
## # A tibble: 60 x 4
##       id Species    value label
##    &lt;int&gt; &lt;fct&gt;      &lt;dbl&gt; &lt;chr&gt;
##  1   117 setosa      7.65 full 
##  2   117 versicolor  6.93 full 
##  3   117 virginica   6.63 full 
##  4   125 setosa      7.87 full 
##  5   125 versicolor  7.15 full 
##  6   125 virginica   6.85 full 
##  7    72 setosa      6.47 full 
##  8    72 versicolor  5.74 full 
##  9    72 virginica   5.44 full 
## 10    82 setosa      6.11 full 
## # ... with 50 more rows
```

```r
light_ice(mod_full, v = "Species", indices = (1:15) * 10)
```

```
## 
## I am an object of class light_ice 
## 
## data.frames:
## 
##  data 
## # A tibble: 45 x 4
##       id Species    value label
##    &lt;dbl&gt; &lt;fct&gt;      &lt;dbl&gt; &lt;chr&gt;
##  1    10 setosa      4.92 full 
##  2    10 versicolor  4.20 full 
##  3    10 virginica   3.90 full 
##  4    20 setosa      5.20 full 
##  5    20 versicolor  4.48 full 
##  6    20 virginica   4.18 full 
##  7    30 setosa      5.02 full 
##  8    30 versicolor  4.30 full 
##  9    30 virginica   4.00 full 
## 10    40 setosa      5.04 full 
## # ... with 35 more rows
```

---


```r
light_ice(mod_full, v = "Species", evaluate_at = levels(iris$Species))
```

```
## 
## I am an object of class light_ice 
## 
## data.frames:
## 
##  data 
## # A tibble: 60 x 4
##       id Species    value label
##    &lt;int&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;
##  1    46 setosa      4.73 full 
##  2    46 versicolor  4.00 full 
##  3    46 virginica   3.70 full 
##  4    99 setosa      5.55 full 
##  5    99 versicolor  4.83 full 
##  6    99 virginica   4.53 full 
##  7    67 setosa      6.92 full 
##  8    67 versicolor  6.19 full 
##  9    67 virginica   5.89 full 
## 10   109 setosa      7.65 full 
## # ... with 50 more rows
```

```r
light_ice(mod_full, grid = grid, data = iris[1,])$data
```

```
## # A tibble: 9 x 5
##      id Species    Petal.Length value label
##   &lt;int&gt; &lt;fct&gt;             &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;
## 1     1 setosa                2  5.50 full 
## 2     1 versicolor            2  4.78 full 
## 3     1 virginica             2  4.48 full 
## 4     1 setosa                3  6.33 full 
## 5     1 versicolor            3  5.61 full 
## 6     1 virginica             3  5.31 full 
## 7     1 setosa                4  7.16 full 
## 8     1 versicolor            4  6.44 full 
## 9     1 virginica             4  6.14 full
```

---


```r
#light_ice(mods, v = "Species", indices = (1:15) * 10)
#light_ice(mods, v = "Species", indices = (1:15) * 10, center = TRUE)
#light_ice(mods, v = "Petal.Width", n_bins = 5)
```

---


```r
light_ice(mods, v = "Petal.Width", by = "Species", n_bins = 5)
```

```
## 
## I am an object of class light_ice_multi 
## 
## data.frames:
## 
##  data 
## # A tibble: 200 x 5
##       id Species    Petal.Width value label
##    &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;
##  1    73 versicolor        0.25  6.67 full 
##  2    73 versicolor        0.75  6.51 full 
##  3    73 versicolor        1.25  6.36 full 
##  4    73 versicolor        1.75  6.20 full 
##  5    73 versicolor        2.25  6.04 full 
##  6    56 versicolor        0.25  6.49 full 
##  7    56 versicolor        0.75  6.33 full 
##  8    56 versicolor        1.25  6.17 full 
##  9    56 versicolor        1.75  6.02 full 
## 10    56 versicolor        2.25  5.86 full 
## # ... with 190 more rows
```

```r
light_ice(mods, v = "Petal.Width", by = "Species",
id_name = "profile", value_name = "val", label_name = "lab")
```

```
## Warning in warning_on_names(c("value_name", "label_name", "id_name"), ...):
## Using 'xyz_name' arguments is deprecated. Use 'options(flashlight.xyz_name
## = ...)' instead.

## Warning in warning_on_names(c("value_name", "label_name", "id_name"), ...):
## Using 'xyz_name' arguments is deprecated. Use 'options(flashlight.xyz_name
## = ...)' instead.
```

```
## 
## I am an object of class light_ice_multi 
## 
## data.frames:
## 
##  data 
## # A tibble: 880 x 5
##       id Species   Petal.Width value label
##    &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;
##  1   142 virginica         0.1  6.88 full 
##  2   142 virginica         0.2  6.85 full 
##  3   142 virginica         0.3  6.82 full 
##  4   142 virginica         0.4  6.79 full 
##  5   142 virginica         0.5  6.76 full 
##  6   142 virginica         0.6  6.73 full 
##  7   142 virginica         1    6.60 full 
##  8   142 virginica         1.1  6.57 full 
##  9   142 virginica         1.2  6.54 full 
## 10   142 virginica         1.3  6.50 full 
## # ... with 870 more rows
```

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
