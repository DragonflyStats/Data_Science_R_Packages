---
title: "``l_layer_heatImage ``"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(loon)
```

Display a Heat Image

#### Description 

This function is very similar to the image function. It works with every loon plot which is based on
the cartesian coordinate system.

#### Usage
<pre><code>

l_layer_heatImage(widget, x = seq(0, 1, length.out = nrow(z)),
y = seq(0, 1, length.out = ncol(z)), z,
zlim = range(z[is.finite(z)]), xlim = range(x), ylim = range(y),
col = grDevices::heat.colors(12), breaks, oldstyle = FALSE,
useRaster, index = "end", parent = "root", ...)

</code></pre>
#### Arguments 

* ``widget``: widget path as a string or as an object handle
* x locations of grid lines at which the values in z are measured. These must be
finite, non-missing and in (strictly) ascending order. By default, equally spaced
values from 0 to 1 are used. If x is a list, its components x$x and x$y are used
for x and y, respectively. If the list has component z this is used for z.
y see Description 
 for the x argument above
* z a numeric or logical matrix containing the values to be plotted (NAs are allowed).
Note that x can be used instead of z for convenience.
* zlim the minimum and maximum z values for which colors should be plotted, defaulting
to the range of the finite values of z. Each of the given colors will be
used to color an equispaced interval of this range. The midpoints of the intervals
cover the range, so that values just outside the range will be plotted.
* xlim range for the plotted x values, defaulting to the range of x
* ylim range for the plotted y values, defaulting to the range of y
* col a list of colors such as that generated by rainbow, heat.colors, topo.colors, terrain.colors or similar functions.
* breaks a set of finite numeric breakpoints for the colours: must have one more breakpoint than colour and be in increasing order. Unsorted vectors will be sorted,with a warning.
* oldstyle logical. If true the midpoints of the colour intervals are equally spaced, and ``zlim[1]`` and ``zlim[2]`` were taken to be midpoints. The default is to have colour intervals of equal lengths between the limits.
* useRaster logical; if TRUE a bitmap raster is used to plot the image instead of polygons. The
grid must be regular in that case, otherwise an error is raised. For the behaviour when this is not specified, see ' Details '.
* index position among its siblings. valid values are 0, 1, 2, ..., 'end'
* ``parent ``:  parent widget path
* ... arguments forwarded to l_layer_line



#### Examples 
```{r}
if (requireNamespace("MASS", quietly = TRUE)) {
kest <- with(iris, MASS::kde2d(Sepal.Width,Sepal.Length))
image(kest)
contour(kest, add=TRUE)
p <- l_plot()
lcl <- l_layer_contourLines(p, kest, label='contour lines')
limg <- l_layer_heatImage(p, kest, label='heatmap')
l_scaleto_world(p)
}
```


```{r}
# from Examples (image)
x <- y <- seq(-4*pi, 4*pi, len = 27)
r <- sqrt(outer(x^2, y^2, "+"))
p1 <- l_plot()
l_layer_heatImage(p1, z = z <- cos(r^2)*exp(-r/6), col = gray((0:32)/32))
l_scaleto_world(p1)
image(z = z <- cos(r^2)*exp(-r/6), col = gray((0:32)/32))
```

#### Details 

For more information run: l_help("learn_R_layer.html#countourlines-heatimage-rasterimage")

#### Value
layer id of group or rectangles layer